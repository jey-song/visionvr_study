# Demystify SwiftUI

### # Identity身份
#### 1. 了解
* SwiftUI 在应用程序的多次更新中识别相同或不同元素的方式。
* 是否为同一个id，决定视图是否相同，然后决定了动画方式
	* 不同视图淡入淡出，相同视图移动

#### 2. 类型
* 显式身份explicit identity：使用自定义或数据驱动的标识符。
* 结构标识：根据视图的类型和在视图层次结构中的位置来区分视图。

#### 3. 结构标识
* 每个SwiftUI的View都有一个id，即使没有显示id

 | NSView UIView  | SwiftUI View
----- | ------------- | -------------
Id | Pointer Id | 两种id

* AnyView - 使用ViewBuilder包装器声明减少AnyView
	* 避免使用AnyView
	* 会使得代码更难阅读理解
		* if-else和 switch更好
	* 有时会阻止代码中出现有用的诊断错误和警告
	* 可能会导致性能下降
* 使用泛型保留静态类型信息，而不是AnyView


### # 生命周期
* SwiftUI 跟踪视图和数据随时间的存在情况的方式。
* 身份允许我们随着时间的推移为不同的值定义一个稳定的元素

#### 1. 介绍
* 视图的值 ≠ 视图标识
* 视图生命周期 = 视图id
	* 视图的标识发生更改或视图被删除，其生命周期就会结束。
	* 将视图的标识与其生命周期联系起来是理解 SwiftUI 如何持久化状态的基础。
* State生命周期 = View生命周期

**视图值是短暂的，不应该依赖它们的生命周期。**

**控制视图的Id，并且可以使用Id来明确确定状态生命周期的范围。**

**持续的状态控制生命周期，数据驱动**

**SwiftUI 充分利用数据驱动组件的可识别协议，因此为数据选择稳定的标识符非常重要。**

### # 依赖关系
* SwiftUI 如何理解您的界面何时需要更新以及原因。

##### 依赖图Dependency graph
* 身份是依赖图的支柱。
* 该标识是 SwiftUI 如何将更改路由到正确的视图并有效更新 UI 的方式。

##### 依赖的类型
* 结构体的动态可变属性
* 解释标识符
	* 稳定性
	* 唯一性，多个视图不能共享标识符。
	* 标识符不应随时间而改变

* “惰性修饰符”（透明度1，透明度0等）
	* 成本很小，框架可有效的删除修饰符
	* 替代分支产生的结构标识
	
```
* 不必要地使用分支时，它们可能会导致性能不佳、动画令人惊讶，甚至如 Luca 所示，甚至会导致状态丢失。
* 使用 inert 修饰符而不是分支来识别单个视图通常效果更好。
* 引入分支时，请暂停一秒钟并考虑您是代表多个视图还是同一视图的两种状态。
```


